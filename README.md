# PR Reviewer Assignment Service

Микросервис для автоматического назначения ревьюеров на Pull Request'ы с возможностью управления командами и участниками.

## Описание

Сервис автоматически назначает до двух активных ревьюеров из команды автора при создании PR. Поддерживается переназначение ревьюеров и получение статистики назначений. После merge PR изменение состава ревьюеров запрещено.

### Основные возможности

- Автоматическое назначение до двух ревьюеров при создании PR
- Переназначение ревьюеров с учетом доступности команды
- Управление командами и статусом активности участников
- Получение статистики по назначениям
- Идемпотентная операция merge

## Требования

- Docker и Docker Compose
- (Опционально) Go 1.21+ для локальной разработки
- (Опционально) jq для форматированного вывода в тестовом скрипте

## Быстрый старт

### Запуск через Docker Compose

```bash
# Клонировать репозиторий
git clone <repository-url>
cd pr-reviewer-assignment-service

# Запустить сервис и базу данных
docker-compose up

# Сервис будет доступен на http://localhost:8080
```

Команда `docker-compose up` автоматически выполнит следующие действия:
1. Запустит PostgreSQL контейнер и дождется готовности базы данных
2. Создаст необходимую схему (таблицы и индексы)
3. Запустит приложение на порту 8080

### Проверка работоспособности

```bash
curl http://localhost:8080/health

# Ожидаемый ответ:
# {"status":"ok"}
```

### Использование Makefile

```bash
# Собрать бинарный файл
make build

# Запустить приложение локально (требуется запущенная БД)
make run

# Запустить unit тесты
make test

# Запустить интеграционные тесты (требуется PostgreSQL)
make test-integration

# Запустить интеграционные тесты через Docker
make test-integration-docker

# Запустить все тесты
make test-all

# Запустить все тесты с покрытием
make test-coverage


# Запустить линтер
make lint

# Запустить линтер с автоисправлением
make lint-fix

# Полная проверка кода (форматирование + vet + lint + тесты)
make check

# Собрать Docker образ
make docker-build

# Запустить через docker-compose
make docker-up

# Остановить контейнеры
make docker-down

# Просмотреть логи
make docker-logs

# Очистить артефакты сборки
make clean

# Показать все доступные команды
make help
```

## Структура проекта

```
pr-reviewer-assignment-service/
├── cmd/
│   └── server/
│       └── main.go              # Точка входа приложения
├── internal/
│   ├── config/
│   │   └── config.go            # Конфигурация из переменных окружения
│   ├── domain/
│   │   ├── models.go            # Доменные модели
│   │   ├── models_test.go       # Unit тесты доменных моделей
│   │   └── errors.go            # Доменные ошибки
│   ├── http/
│   │   └── handlers/
│   │       └── handlers.go      # HTTP handlers и маршрутизация
│   ├── repository/
│   │   └── postgres.go          # Работа с PostgreSQL
│   ├── service/
│   │   ├── service.go           # Реализация бизнес-логики
│   │   └── interface.go         # Интерфейс сервисного слоя
│   └── storage/
│       └── schema/
│           └── schema.go        # SQL схема базы данных
├── test/
│   └── integration/
│       └── repository_integration_test.go  # Интеграционные тесты
├── docker-compose.yml           # Docker окружение
├── Dockerfile                   # Образ приложения
├── Makefile                     # Команды сборки и запуска
├── go.mod                       # Go зависимости
├── .golangci.yml               # Конфигурация линтера
└── README.md                    # Документация
```

## API документация

### Аутентификация

Все эндпоинты кроме `/health` требуют токен авторизации в заголовке:

```
Authorization: Bearer <token>
```

Доступны два типа токенов:
- **Admin токен** - полный доступ ко всем операциям
- **User токен** - доступ только к операциям чтения

Токены настраиваются через переменные окружения `ADMIN_TOKEN` и `USER_TOKEN`.

### Эндпоинты

#### Health Check

```bash
GET /health

# Ответ: 200 OK
{
  "status": "ok"
}
```

#### Команды

**Создание команды**

```bash
POST /team/add
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "team_name": "backend",
  "members": [
    {"user_id": "u1", "username": "Alice", "is_active": true},
    {"user_id": "u2", "username": "Bob", "is_active": true}
  ]
}

# Ответ: 201 Created
{
  "team": {
    "team_name": "backend",
    "members": [...]
  }
}
```

**Получение команды**

```bash
GET /team/get?team_name=backend
Authorization: Bearer <user-token>

# Ответ: 200 OK
{
  "team_name": "backend",
  "members": [...]
}
```

#### Пользователи

**Изменение статуса активности**

```bash
POST /users/setIsActive
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "user_id": "u2",
  "is_active": false
}

# Ответ: 200 OK
{
  "user": {
    "user_id": "u2",
    "username": "Bob",
    "team_name": "backend",
    "is_active": false
  }
}
```

**Получение списка PR для ревью**

```bash
GET /users/getReview?user_id=u2
Authorization: Bearer <user-token>

# Ответ: 200 OK
{
  "user_id": "u2",
  "pull_requests": [
    {
      "pull_request_id": "pr-1",
      "pull_request_name": "Add feature",
      "author_id": "u1",
      "status": "OPEN"
    }
  ]
}
```

#### Pull Requests

**Создание PR**

```bash
POST /pullRequest/create
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "pull_request_id": "pr-1001",
  "pull_request_name": "Add search feature",
  "author_id": "u1"
}

# Ответ: 201 Created
{
  "pr": {
    "pull_request_id": "pr-1001",
    "pull_request_name": "Add search feature",
    "author_id": "u1",
    "status": "OPEN",
    "assigned_reviewers": ["u2", "u3"],
    "createdAt": "2025-11-15T10:30:00Z"
  }
}
```

**Merge PR**

```bash
POST /pullRequest/merge
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "pull_request_id": "pr-1001"
}

# Ответ: 200 OK
{
  "pr": {
    "pull_request_id": "pr-1001",
    "status": "MERGED",
    "mergedAt": "2025-11-15T11:00:00Z",
    ...
  }
}
```

**Переназначение ревьюера**

```bash
POST /pullRequest/reassign
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "pull_request_id": "pr-1001",
  "old_user_id": "u2"
}

# Ответ: 200 OK
{
  "pr": {
    "assigned_reviewers": ["u3", "u4"],
    ...
  },
  "replaced_by": "u4"
}
```

#### Статистика

**Статистика по ревьюерам**

```bash
GET /stats/reviewers
Authorization: Bearer <user-token>

# Ответ: 200 OK
{
  "reviewers": [
    {
      "user_id": "u2",
      "username": "Bob",
      "total_assignments": 15
    }
  ]
}
```

**Статистика по PR**

```bash
GET /stats/pullRequests
Authorization: Bearer <user-token>

# Ответ: 200 OK
{
  "total_prs": 50,
  "open_prs": 20,
  "merged_prs": 30,
  "prs_with_reviewers": 45,
  "prs_without_reviewers": 5
}
```

### Коды ошибок

| HTTP статус | Error Code | Описание |
|-------------|------------|----------|
| 400 | TEAM_EXISTS | Команда с таким именем уже существует |
| 401 | NOT_FOUND | Неверный токен авторизации |
| 404 | NOT_FOUND | Запрашиваемый ресурс не найден |
| 409 | PR_EXISTS | PR с таким идентификатором уже существует |
| 409 | PR_MERGED | Невозможно изменить смерженный PR |
| 409 | NOT_ASSIGNED | Указанный пользователь не назначен ревьюером |
| 409 | NO_CANDIDATE | Нет доступных кандидатов для замены |

Формат ответа с ошибкой:

```json
{
  "error": {
    "code": "PR_MERGED",
    "message": "pull request already merged"
  }
}
```

## Конфигурация

### Переменные окружения

| Переменная | По умолчанию | Описание |
|------------|--------------|----------|
| `APP_PORT` | `8080` | Порт HTTP сервера |
| `DATABASE_URL` | - | Полная строка подключения к PostgreSQL |
| `DB_HOST` | `postgres` | Хост PostgreSQL |
| `DB_PORT` | `5432` | Порт PostgreSQL |
| `DB_USER` | `postgres` | Пользователь базы данных |
| `DB_PASSWORD` | `postgres` | Пароль базы данных |
| `DB_NAME` | `pr_service` | Имя базы данных |
| `DB_SSLMODE` | `disable` | SSL режим подключения |
| `ADMIN_TOKEN` | `admin-secret` | Токен администратора |
| `USER_TOKEN` | `user-secret` | Токен пользователя |

Если указана переменная `DATABASE_URL`, остальные параметры подключения игнорируются. В противном случае строка подключения формируется из отдельных параметров.

## Архитектура

### Слои приложения

Приложение построено по трехслойной архитектуре:

```
HTTP Layer (handlers)
    ↓
Service Layer
    ↓
Repository Layer
    ↓
PostgreSQL
```

**HTTP Layer** отвечает за обработку HTTP запросов, валидацию входных данных и авторизацию.

**Service Layer** содержит бизнес-логику приложения. В текущей реализации служит промежуточным слоем между handlers и repository.

**Repository Layer** инкапсулирует работу с базой данных, выполняет SQL запросы и управляет транзакциями.

### База данных

**Таблицы:**

- `teams` - команды разработчиков
- `users` - пользователи с флагом активности и привязкой к команде
- `pull_requests` - pull request'ы со статусом и временными метками
- `pull_request_reviewers` - связь many-to-many между PR и ревьюерами

**Ключевые особенности схемы:**

- Foreign keys с `ON DELETE RESTRICT` для предотвращения каскадного удаления критичных данных
- Foreign keys с `ON DELETE CASCADE` для автоматического удаления зависимых записей
- Индексы на часто используемых полях для оптимизации запросов
- Использование транзакций для обеспечения атомарности операций

### Алгоритм назначения ревьюеров

**При создании PR:**

1. Получаем информацию об авторе и его команде
2. Выбираем активных участников команды, исключая автора
3. Применяем случайную сортировку через `ORDER BY random()`
4. Ограничиваем выборку двумя записями
5. Назначаем выбранных ревьюеров в рамках транзакции вместе с созданием PR

**При переназначении:**

1. Проверяем, что PR находится в статусе OPEN
2. Проверяем, что указанный пользователь действительно назначен ревьюером
3. Получаем список активных участников из команды заменяемого ревьюера
4. Исключаем уже назначенных ревьюеров и автора PR
5. Выбираем первого подходящего кандидата
6. Выполняем замену в рамках транзакции

## Тестирование

### Unit тесты

Реализованы unit тесты для доменных моделей:

```bash
# Запуск unit тестов
go test ./internal/domain/

# С покрытием
go test -cover ./internal/domain/

# Или через Makefile
make test
```

### Интеграционные тесты

Интеграционные тесты проверяют работу с реальной базой данных PostgreSQL. Тесты покрывают:

- Создание и получение команд
- Управление активностью пользователей
- Создание PR с автоматическим назначением ревьюеров
- Операции merge и переназначения
- Получение статистики
- Граничные случаи и ошибки

```bash
# Вариант 1: Использовать существующую PostgreSQL
# Требуется PostgreSQL на localhost:5432
make test-integration

# Вариант 2: Запустить PostgreSQL через Docker
make test-integration-docker

# Вариант 3: Запустить напрямую с указанием БД
TEST_DATABASE_URL="postgres://user:pass@host:5432/testdb?sslmode=disable" \
  go test -v ./test/integration/

# Запустить все тесты (unit + integration)
make test-all
```

**Примечание:** Интеграционные тесты создают и очищают тестовую базу данных `pr_service_test`. Убедитесь что PostgreSQL доступен перед запуском.


Скрипт проверяет следующие сценарии:

- Создание команд и обработка дубликатов
- Получение информации о команде
- Создание PR с автоматическим назначением ревьюеров
- Переназначение ревьюеров
- Изменение статуса активности пользователей
- Операция merge и её идемпотентность
- Попытки изменения смерженного PR
- Проверка авторизации

## Принятые решения и допущения

В процессе разработки были приняты следующие архитектурные решения. Для каждого решения указано обоснование выбора и рассмотренные альтернативы.

### 1. Структура слоев приложения

**Решение:** Реализована трехслойная архитектура с выделением интерфейса сервисного слоя. Service слой реализует интерфейс `ServiceInterface`, который определяет контракт для всех операций бизнес-логики.

**Обоснование:**
- Интерфейс позволяет легко создавать mock-реализации для тестирования HTTP handlers
- Service слой оставлен для обеспечения возможности расширения функциональности в будущем
- Слой может быть использован для добавления кеширования, дополнительных валидаций, интеграции с внешними сервисами или логирования бизнес-событий без изменения других слоев
- Handlers зависят от интерфейса, а не от конкретной реализации, что соответствует принципу инверсии зависимостей (DIP)

**Альтернативы:** Можно было исключить Service слой и вызывать Repository напрямую из Handlers, что упростило бы текущую реализацию, но затруднило бы будущее расширение и тестирование.

### 2. Алгоритм выбора ревьюеров

**Решение:** Для выбора ревьюеров используется SQL запрос с `ORDER BY random() LIMIT 2`.

**Обоснование:**
- Простота реализации без необходимости хранения дополнительного состояния
- Статистически равномерное распределение нагрузки между участниками
- Отсутствие проблем с конкурентным доступом
- Эффективное выполнение на уровне базы данных

**Альтернативы:**
- Round-robin алгоритм требует глобальной очереди и синхронизации состояния
- Выбор по минимальной нагрузке требует дополнительных запросов для подсчета активных назначений
- Weighted random позволяет учитывать приоритеты, но усложняет логику

**Ограничения:** При значительном увеличении размера команды (более 1000 участников) производительность `random()` может снизиться. В таком случае можно использовать табличное сэмплирование или кеширование активных участников.

### 3. Управление транзакциями

**Решение:** Транзакции используются для критичных операций (создание команды, создание PR, переназначение), но без применения `SELECT FOR UPDATE`.

**Обоснование:** Для заданных требований (RPS = 5, умеренный объем данных) подход с минимальными блокировками обеспечивает достаточную производительность. Операции назначения ревьюеров не являются критичными с точки зрения строгой консистентности, поэтому редкие race condition приемлемы.

**Альтернатива:** Для систем с высокими требованиями к консистентности можно добавить `SELECT ... FOR UPDATE` для явной блокировки записей на время транзакции.

### 4. Идемпотентность операции merge

**Решение:** Повторный вызов merge для уже смерженного PR возвращает статус 200 с текущим состоянием PR.

**Обоснование:** Согласно требованиям задания, операция merge должна быть идемпотентной. Это соответствует лучшим практикам проектирования REST API, где повторное выполнение идемотентной операции не приводит к ошибке и возвращает актуальное состояние ресурса.

### 5. Авторизация через токены

**Решение:** Реализована простая токен-авторизация с двумя уровнями доступа (admin/user), токены передаются в заголовке Authorization.

**Обоснование:** Для демонстрационного проекта выбран простой и понятный механизм авторизации, который легко настраивается через переменные окружения и не требует дополнительной инфраструктуры.

**Для production окружения рекомендуется:** JWT токены с подписью и временем жизни, интеграция с OAuth 2.0/OIDC провайдерами, использование Secrets Manager для хранения токенов.

### 6. Создание схемы базы данных

**Решение:** Схема создается при старте приложения через `CREATE TABLE IF NOT EXISTS`.

**Обоснование:** Согласно требованиям задания, сервис и его зависимости должны подниматься командой `docker-compose up`, при этом миграции должны применяться автоматически. Использование `IF NOT EXISTS` обеспечивает идемпотентность и простоту развертывания.

**Альтернатива:** Для production систем рекомендуется использовать специализированные инструменты миграций (golang-migrate, Flyway, Liquibase) с версионированием схемы и возможностью отката.

### 7. Обработка ошибок

**Решение:** Доменные ошибки определены как глобальные переменные в пакете domain, маппинг на HTTP статусы выполняется в слое handlers.

**Обоснование:** Разделение доменных и HTTP ошибок позволяет переиспользовать доменную логику независимо от транспортного уровня.

**Известная проблема:** В текущей реализации некоторые ошибки некорректно маппятся на код `NOT_FOUND` вместо более специфичных кодов (например, `INVALID_INPUT` для ошибок валидации). Это следует исправить для улучшения клиентского опыта.

### 8. Отсутствие пагинации

**Решение:** Эндпоинты, возвращающие списки, не поддерживают пагинацию.

**Обоснование:** Согласно требованиям задания, объем данных умеренный (до 20 команд и до 200 пользователей). При таких объемах пагинация не критична для производительности.

**Для масштабирования:** При увеличении объема данных следует добавить параметры `page`, `limit` или cursor-based пагинацию.

### 9. Выбор технологий

**PostgreSQL:** Выбран за богатый функционал (FILTER в агрегациях, эффективный random(), поддержка JSON), надежность и соответствие требованиям задания.

**pgx драйвер:** Предоставляет лучшую производительность по сравнению с database/sql и нативную поддержку специфичных фич PostgreSQL.

**Chi router:** Легковесный, производительный, с удобным middleware API и совместимостью с стандартными http.Handler.

**Отсутствие ORM:** Решение принято в пользу прямого контроля над SQL запросами, что важно для оптимизации производительности сложных запросов (агрегации, случайная выборка).

### 10. Graceful shutdown

**Решение:** При получении сигнала SIGTERM/SIGINT сервер прекращает принимать новые соединения и ожидает завершения активных запросов в течение 10 секунд.

**Обоснование:** Это обеспечивает корректное завершение обработки запросов при деплое новых версий или остановке контейнера. Таймаут в 10 секунд является балансом между необходимостью завершить работу и временем ожидания при деплое.

## Производительность

### Оптимизации

- Connection pooling через pgxpool для эффективного переиспользования соединений с БД
- Индексы на внешних ключах для ускорения join операций
- Выполнение случайной выборки на уровне базы данных
- Минимальное использование блокировок в транзакциях
- Использование prepared statements через параметризованные запросы

## Известные ограничения

### Текущие ограничения

1. **Простая авторизация:** Токены хранятся в plain text в переменных окружения
2. **Отсутствие rate limiting:** Нет защиты от превышения допустимого RPS
3. **Отсутствие структурированного логирования:** Используется стандартный log пакет
4. **Некорректный маппинг кодов ошибок:** Некоторые ошибки возвращают generic код `NOT_FOUND`
5. **Отсутствие метрик:** Нет встроенного мониторинга производительности

### Рекомендации по улучшению

- Внедрение структурированного логирования (zerolog, zap)
- Использование JWT токенов вместо статичных
- Корректный маппинг доменных ошибок на HTTP коды

## Линтер

Проект использует golangci-lint для статического анализа кода. Конфигурация находится в файле `.golangci.yml`.

### Настройка линтера

**Включенные линтеры:**

- `errcheck` - проверка необработанных ошибок
- `gosec` - проверка на проблемы безопасности
- `govet` - стандартный анализатор Go
- `ineffassign` - обнаружение неэффективных присваиваний
- `staticcheck` - расширенный статический анализ
- `unused` - поиск неиспользуемого кода

**Основные настройки:**

- Таймаут выполнения: 5 минут
- Максимальная длина строки: 150 символов
- Минимальная цикломатическая сложность: 20
- Проверка затенения переменных включена

**Исключения:**

Для тестовых файлов отключены некоторые проверки (errcheck, gocyclo, lll), так как тестовый код может быть менее строгим. Также исключены автоматически генерируемые файлы (*.pb.go, *.gen.go).

### Запуск линтера

```bash
# Установка golangci-lint (если не установлен)
# macOS
brew install golangci-lint

# Linux
curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin

# Запуск линтера
golangci-lint run

# Или через Makefile
make lint

# С автоматическим исправлением
golangci-lint run --fix
```



